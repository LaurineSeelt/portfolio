---
author: "Laurine Seelt"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
biblio-style: apalike
link-citations: yes
---

# Free space

This was the fifth assignment for our portfolio. We had/have to fill 32 hours learning something new that will be useful for our internship next year and possibly our job.



- Uitzoeken welke automatiseringen er op microbiologische labs worden gebruikt.
- Metagenomics? 
https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-020-03933-4 (megaR package)
http://web.evolbio.mpg.de/~wang/Site/R_tutorial_files/16S%20Metagenomic%20Analysis%20Tutorial.pdf (random tutorial)
https://www.mcs.anl.gov/~braithwaite/matR/docs-and-pubs/matR-user-manual.pdf (matR package)
https://rpubs.com/jrandall7/EICC16s (phyloseq)
https://cran.r-project.org/web/packages/microbial/microbial.pdf (microbial package)
https://bioconductor.org/help/course-materials/2017/BioC2017/Day1/Workshops/Microbiome/MicrobiomeWorkflowII.html (aritkel over microbioom analyse workflow)

https://www.nicholas-ollberding.com/post/introduction-to-the-statistical-analysis-of-microbiome-data-in-r/ (soort course over de analyse van microbioom data)
https://rstudio-pubs-static.s3.amazonaws.com/268156_d3ea37937f4f4469839ab6fa2c483842.html (ook een course over de analyse van microbiota data)
https://grunwaldlab.github.io/analysis_of_microbiome_community_data_in_r/04--manipulating.html (nog een course)
- Python?

## Course: Introduction to the statistical analysis of microbiome data in R
Link to the course: https://www.nicholas-ollberding.com/post/introduction-to-the-statistical-analysis-of-microbiome-data-in-r/

In this course, we examined the differences in microbiota between patients with and without chronic fatigue syndrome.
The aspects that were looked at were: <br>
Taxonomic relative abundance <br>
Hierarchal clustering <br>
Alpha-diversity (microbiome diversity in just one sample) <br>
Beta-divesity (microbiome diversity in two or more samples) <br>
Diffrential abundance testing <br>
Predicting class labels <br>

```{r installing all the required packages, include=TRUE, message=FALSE, warning=FALSE, eval=FALSE}
.cran_packages <- c("tidyverse", "cowplot", "picante", "vegan", "HMP", "dendextend", "rms", "devtools")
.bioc_packages <- c("phyloseq", "DESeq2", "microbiome", "metagenomeSeq", "ALDEx2")
.inst <- .cran_packages %in% installed.packages()
if(any(!.inst)) {
  install.packages(.cran_packages[!.inst])
}
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install(.bioc_packages, version = "3.15") #Changed 3.9 to 3.15
devtools::install_github("adw96/breakaway")
devtools::install_github(repo = "malucalle/selbal") #changed UVic-omics to malucalle
```

```{r loading the required packages, message=FALSE, warning=FALSE}
library(tidyverse)
library(phyloseq)
library(DESeq2)
library(microbiome)
library(vegan)
library(picante)
library(ALDEx2)
library(metagenomeSeq)
library(HMP)
library(dendextend)
library(selbal)
library(rms)
library(breakaway)
```

```{r, message=FALSE, warning=FALSE}
# Reading in the data
ps <- readRDS("Data/Data_raw/ps_giloteaux_2016.rds")
# Sorting the samples on total read count
sort(phyloseq::sample_sums(ps))
# Removing (samples with?) less than 5000 reads
(ps <- phyloseq::subset_samples(ps, phyloseq::sample_sums(ps) > 5000))
# Removing the OTU's that were only present in the removed samples
(ps <- phyloseq::prune_taxa(phyloseq::taxa_sums(ps) > 0, ps))
# Assigning a new metadata field
phyloseq::sample_data(ps)$Status <- ifelse(phyloseq::sample_data(ps)$Subject == "Patient", "Chronic Fatique", "Control")
phyloseq::sample_data(ps)$Status <- factor(phyloseq::sample_data(ps)$Status, levels = c("Control", "Chronic Fatique"))
ps %>% sample_data %>% dplyr::count(Status)
```

```{r, message=FALSE, warning=FALSE}
# Counting all the phyla in the dataset
table(phyloseq::tax_table(ps)[, "Phylum"])
# Convert the samples to relative abundances
ps_rel_abund = phyloseq::transform_sample_counts(ps, function(x){x / sum(x)})
phyloseq::otu_table(ps)[1:5, 1:5] # Before we converted it to relative abundances
phyloseq::otu_table(ps_rel_abund)[1:5, 1:5] # After we calculated the relative abundances

# Plotting the relative abundances, devided by the two groups
phyloseq::plot_bar(ps_rel_abund, fill = "Phylum")+
  geom_bar(aes(color = Phylum, fill = Phylum), stat = "identity", position = "stack")+
  labs(x = "", y = "Relative Abundance\n")+
  facet_wrap(~ Status, scales = "free")+
  theme(panel.background = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
```

```{r extra, message=FALSE, warning=FALSE, eval=FALSE}
# Sorting the taxa by their relative abundance
sort(ps_rel_abund@tax_table[["Phylum"]], decreasing = TRUE) %>%  phyloseq::plot_bar(fill = "Phylum")+
  geom_bar(aes(color = Phylum, fill = Phylum), stat = "identity", position = "stack")+
  labs(x = "", y = "Relative Abundance\n")+
  facet_wrap(~ Status, scales = "free")+
  theme(panel.background = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
```

```{r generating boxplots according to the groups, message=FALSE, warning=FALSE}
# Grouping the taxa according to phylum and renaming the groups
ps_phylum <- phyloseq::tax_glom(ps, "Phylum")
phyloseq::taxa_names(ps_phylum) <- phyloseq::tax_table(ps_phylum)[, "Phylum"]
phyloseq::otu_table(ps_phylum)[1:5, 1:5]

# Melting the data and making the boxplots
phyloseq::psmelt(ps_phylum) %>%
  ggplot(data = ., aes(x = Status, y = Abundance))+
  geom_boxplot(outlier.shape = NA)+
  geom_jitter(aes(colour = OTU), height = 0, width = 0.2)+
  labs(x = "", y = "Abundance\n")+
  facet_wrap(~ OTU, scales = "free")
```

```{r looking at the frequencies of the taxa in both groups, message=FALSE, warning=FALSE}
# Making two subsets
controls <- phyloseq::subset_samples(ps_phylum, Status == "Control")
cf <- phyloseq::subset_samples(ps_phylum, Status = "Chronic Fatigue")

# Looking at the OTU tables
control_otu <- data.frame(phyloseq::otu_table(controls))
cf_otu <- data.frame(phyloseq::otu_table(cf))

# Grouping the rare phyla to improve testing
control_otu <- control_otu %>% t(.) %>% as.data.frame(.) %>% mutate(Other = Cyanobacteria + Euryarchaeota + Tenericutes + Verrucomicrobia + Fusobacteria) %>% dplyr::select(-Cyanobacteria, -Euryarchaeota, -Tenericutes, -Verrucomicrobia, -Fusobacteria)
cf_otu <- cf_otu %>% t(.) %>% as.data.frame(.) %>% mutate(Other = Cyanobacteria + Euryarchaeota + Tenericutes + Verrucomicrobia + Fusobacteria) %>% dplyr::select(-Cyanobacteria, -Euryarchaeota, -Tenericutes, -Verrucomicrobia, -Fusobacteria)

# Performing the HMP test
group_data <- list(control_otu, cf_otu)
(xdc <- HMP::Xdc.sevsample(group_data))

1 - pchisq(0.2769004, 5) # Looking at the Chi-Squared distribution
```

Since the P-value of the HMP test is nearly 1, we cannot reject the null hypothesis that there is no statistical significant distribution of phyla between the two groups.

__Looking at the hierarchical clustering in the samples__
<br>
```{r looking at hierarchical clustering, message=FALSE, warning=FALSE}
# Extracting the OTU table
ps_rel_otu <- data.frame(phyloseq::otu_table(ps_rel_abund))
ps_rel_otu <- t(ps_rel_otu)
# Computing the Bray-Curtis dissimilarity
bc_dist <- vegan::vegdist(ps_rel_otu, method = "bray")
# Generating a matrix with the dissimilarities
as.matrix(bc_dist)[1:5, 1:5]
# Saving it as a dendrogram
ward <- as.dendrogram(hclust(bc_dist, method = "ward.D2"))
# Adding color coding
meta <- data.frame(phyloseq::sample_data(ps_rel_abund))
colorCode <- c(Control = "red", `Chronic Fatigue` = "blue")
labels_colors(ward) <- colorCode[meta$Status][order.dendrogram(ward)]
# Plotting the dendrogram
plot(ward)
```

```{r extra trying to create heatmaps for the two different groups, message=FALSE, warning=FALSE, eval=FALSE}
plot_heatmap(cf)
plot_heatmap(controls)
```

__Looking at the alpha diversity__
<br>
Alpha diversity looks at the diversity _within_ a sample and how the observed OTU's are distributed.
```{r, message=FALSE, warning=FALSE}
# Plotting the observed richness
ggplot(data = data.frame("total_reads" = phyloseq::sample_sums(ps),
                         "observed" = phyloseq::estimate_richness(ps, measures = "Observed")[, 1]),
       aes(x = total_reads, y = observed)) +
  geom_point() +
  geom_smooth(method="lm", se = FALSE) +
  labs(x = "\nTotal Reads", y = "Observed richness\n")
```

Now we're going to subsample the reads, plot them and test for group differences
<br>
```{r, message=FALSE, warning=FALSE}
# Subsample reads
(ps_rare <- phyloseq::rarefy_even_depth(ps, rngseed = 123, replace = FALSE))
head(phyloseq::sample_sums(ps_rare))
# Making a dataframe with the adiv measures, another package to analyse and measure biodiversity
adiv <- data.frame("Observed" = phyloseq::estimate_richness(ps_rare, measures = "Observed"),
"Shannon" = phyloseq::estimate_richness(ps_rare, measures = "Shannon"),
"PD" = picante::pd(samp = data.frame(t(data.frame(phyloseq::otu_table(ps_rare)))), include.root = FALSE, tree=phyloseq::phy_tree(ps_rare))[, 1],
"Status" = phyloseq::sample_data(ps_rare)$Status) # Zelf "include.root = FALSE" toegevoegd, anders kreeg ik steeds een error
head(adiv)
# Plotting the adiv measures
adiv %>% gather(key = metric, value = value, c("Observed", "Shannon", "PD")) %>%
  mutate(metric = factor(metric, levels = c("Observed", "Shannon", "PD"))) %>%
  ggplot(aes(x = Status, y = value)) +
  geom_boxplot(outlier.color = NA) +
  geom_jitter(aes(color = Status), height = 0, width = 0.2) +
  labs(x = "", y = "") +
  facet_wrap(~metric, scales = "free") +
  theme(legend.position = "none")
# Summarising the data
adiv %>% group_by(Status) %>% 
  dplyr::summarise(median_observed = median(Observed),
                   median_shannon = median(Shannon),
                   median_pd = median(PD))
# Performing the Wilcoxon tests for the three estimates
wilcox.test(Observed ~ Status, data = adiv, exact = FALSE, conf.int = TRUE)
wilcox.test(Shannon ~ Status, data = adiv, conf.int = TRUE)
wilcox.test(PD ~ Status, data = adiv, conf.int = TRUE)
```

__Looking at the beta diversity__
<br>
Beta diversity looks at the diversity _between_ samples and how it's similar or dissimilar.
```{r,message=FALSE, warning=FALSE}
# Transforming the Total Read Counts according to the Centered Log Ratio method
(ps_clr <- microbiome::transform(ps, "clr"))
phyloseq::otu_table(ps)[1:5, 1:5] # Old OTU table
phyloseq::otu_table(ps_clr)[1:5, 1:5] # New OTU table
# The value are now the dominance for each taxa relative to the geometric mean of all taxa on the logarithmic scale
```
<br>
<br>

## Course: Microbiota analysis in R
Link to the course: https://rstudio-pubs-static.s3.amazonaws.com/268156_d3ea37937f4f4469839ab6fa2c483842.html
<br>
<br>
In this course, we will be looking at the fecal bacterial microbiota of 8 calves at ages 2 weeks, 8 weeks and 1 year old and correlating them with variables such as weight gain, expressed as Average Daily Gain in Kilograms(ADGKG), and gastrointestinal short chain fatty acids, SCFA.
<br>
```{r downloading and loading the packages, message=FALSE, warning=FALSE}
# install.packages("ape")
library(ape)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(gplots)
library(lme4)
library(phangorn)
library(plotly)
library(tidyr)
library(here)
library(vegan)
# install.packages("VennDiagram")
library(VennDiagram)
# Installed Java from: https://www.java.com/en/download/manual.jsp
# Installed Java JDk from: https://www.oracle.com/java/technologies/downloads/#jdk18-windows
# install.packages("rJava")
library(rJava)
# install.packages("venneuler")
# library(venneuler) # R kapt er steeds mee als ik deze wil laden
# if (!require("BiocManager", quietly = TRUE))
    # install.packages("BiocManager")
# BiocManager::install(version = "3.15") # Instead of source("https://bioconductor.org/biocLite.R")
# BiocManager::install("phyloseq") # Instead of biocLite("phyloseq") ?
library(phyloseq)
```

```{r reading in the data, message=FALSE, warning=FALSE}
# Downloaded the data from: https://github.com/kdillmcfarland/workshops_UW_Madison/tree/master/Microbiota_analysis_R/Data
OTU = read.table("Data/example.final.an.unique_list.0.03.norm.shared.txt", header = TRUE, sep = "\t")
tax = read.table("Data/example.final.an.unique_list.0.03.cons.taxonomy.txt", header = TRUE, sep = "\t")
meta = read.table("Data/example.metadata.txt", header = TRUE, row.names = 1, sep = "\t")
SCFA = read.table("Data/example.SCFA.txt", header = TRUE, row.names = 1, sep = "\t")
```

```{r data wrangling, message=FALSE, warning=FALSE}
# Setting the "Group" column as row names in the OTU dataset
row.names(OTU) = OTU$Group
# Removing the columns that are not OTU counts
OTU.clean = OTU[,-which(names(OTU) %in% c("label", "numOtus", "Group"))]
# Setting the "OTU" column as row names in the taxonomy table
row.names(tax) = tax$OTU
# Removing the OTU's that aren't present in the OTU.clean dataset
tax.clean = tax[row.names(tax) %in% colnames(OTU.clean),]
# Separating the taxonomy table so each level has its own column
tax.clean = separate(tax.clean, Taxonomy, into = c("Domain", "Phylum", "Class", "Order", "Family", "Genus", "Species", "Strain"), sep = ";")
# Removing the "Size", "Strain" and "OTU" columns because these are now row names
tax.clean = tax.clean[,-which(names(tax.clean) %in% c("Size", "Strain", "OTU"))]
# Making sure the three datasets have samples in the same order
OTU.clean = OTU.clean[order(row.names(OTU.clean)),]
meta = meta[order(row.names(meta)),]
SCFA = SCFA[order(row.names(SCFA)),]
# set.seed to make the analysis reproducible
set.seed(8765)
```

__Looking at the alpha diversity__ <br>
Alpha diversity is the diversity _within_ a sample. It looks at richness, which is the _amount_ of OTU's in each sample, and at evenness, which is how evenly the different OTU's are distributed within the sample. <br>
```{r looking at the alpha diversity, message=FALSE, warning=FALSE}
# Creating a 2x2 plot environment so we can see all 4 metrics at once
par(mfrow = c(2,2))
# Plotting the four metrics
hist(meta$shannon, main = "Shannon diversity", xlab = "", breaks = 10)
hist(meta$simpson, main = "Simpson diversity", xlab = "", breaks = 10)
hist(meta$chao, main = "Chao richness", xlab = "", breaks = 15)
hist(meta$ace, main = "ACE richness", xlab = "", breaks = 15)
```
<br>
None of the data are normally distributed. Simpson diversity is very often skewed as seen in this histogram, so we'll calculate 1/Simpson and plot the metrics again.
<br>
```{r, message=FALSE, warning=FALSE}
# Creating a 2x2 environment
par(mfrow = c(2,2))
# Plotting the four metrics again
hist(meta$shannon, main = "Shannon diversity", xlab = "", breaks = 10)
hist(1/meta$simpson, main = "Inverse Simpson diversity", xlab = "", breaks = 10)
hist(meta$chao, main = "Chao richness", xlab = "", breaks = 15)
hist(meta$ace, main = "ACE richness", xlab = "", breaks = 15)
```
<br>
Now the Simpson diversity is distributed similarly to the other richness metrics.
<br>
Next, we'll test the four metrics for normal distribution.
<br>
```{r normality tests, message=FALSE, warning=FALSE}
shapiro.test(meta$shannon)
shapiro.test(1/meta$simpson)
shapiro.test(meta$chao)
shapiro.test(meta$ace)
```
<br>
None of the richness metrics are normally distributed, which was to be expected from the graphs we've seen. So we cannot run any tests that assume the data is normally distributed.
<br>
For illustration purposes, we'll run the ANOVA test with the Shannon's diversity because that's the closest to normally distributed. We'll look at if age impacts the Shannon diversity of the fecal microbiota.
<br>
```{r Anova, message=FALSE, warning=FALSE}
aov.shannon.age = aov(shannon ~ AgeGroup, data = meta)
summary(aov.shannon.age)
```
<br>
We'll run Tukey's honest significance test to do pairwise comparisons between groups and correct for multiple comparisons.
<br>
```{r TukeyHSD, message=FALSE, warning=FALSE}
TukeyHSD(aov.shannon.age)
```
<br>
It's clear that all age groups have significantly different diversity. In a plot, we can clearly see that _diversity_ increases with ages.
<br>
```{r plotting the diversity, message=FALSE, warning=FALSE}
# Re-ordering the groups
meta$AgeGroup.ord = factor(meta$AgeGroup, c("2w", "8w", "1yr"))
# Returning the plot area to 1x1
par(mfrow = c(1,1))
# Plotting the diversity
boxplot(shannon ~ AgeGroup.ord, data = meta, 
        ylab = "Shannon's diversity",
        xlab = "Age group") # Added the xlab myself because it looks better :)
```
<br>
To illustrate some non-parametric tests, we'll use Chao's richness estimate. Age is categorical, so we'll use Kruskal-Wallis.
<br>
```{r Kruskal-Wallis, message=FALSE, warning=FALSE}
kruskal.test(chao ~ AgeGroup, data = meta)
```
<br>
We can also test pairwise within age groups with Wilcoxon Rank Sum Tests.
<br>
```{r Wilcoxon Rank Sum Tests, message=FALSE, warning=FALSE}
pairwise.wilcox.test(meta$chao, meta$AgeGroup, p.adjust.method = "fdr")
```
<br>
Just like the diversity, __richness__ also increases with age.
<br>
```{r plotting the richness, message=FALSE, warning=FALSE}
# Creating a 1x1 plot environment
par(mfrow = c(1,1))
# Plotting the richness
boxplot(chao ~ AgeGroup.ord, data = meta,
        ylab = "Chao richness",
        xlab = "Age group") # Again, added the xlab myself for aesthetics :)
```
<br>
Average Daily Gain is a continuous variable, so we'll use a linear model to visualise it.
<br>
We'll use Shannon's diversity again to run some tests that are meant for normally distributed data. We'll take a look at if the ADG impacts the Shannon diversity of the fecal microbiota.
<br>
```{r glm and lm, message=FALSE, warning=FALSE}
glm.shannon.ADG = glm(shannon ~ ADGKG, data = meta)
summary(glm.shannon.ADG)
```
<br>
This shows that the intercept of our model is signficantly different from 0, bu the slope is not, and the slope is our variable of interest.
<br>
Next, let's plot the glm.
<br>
```{r plotting the glm, message=FALSE, warning=FALSE}
plot(shannon ~ ADGKG, data = meta)
abline(glm.shannon.ADG)
```
<br>
To illustrate non-normally distributed data, we'll use Chao's richness estimate again. We'll first use the Gaussian distribution, but we already know this isn't a good fit.
<br>
```{r plotting Gaussian, message=FALSE, warning=FALSE}
gaussian.chao.adg = glm(chao ~ADGKG, data = meta, family = "gaussian")
par(mfrow = c(1,2))
plot(gaussian.chao.adg, which = c(1,2))
```
<br>
Next, we'll plot the quasipoisson distribuiton.
<br>
```{r plotting quasipoisson, message=FALSE, warning=FALSE}
qp.chao.ADG = glm(chao ~ ADGKG, data = meta, family = "quasipoisson")
par(mfrow = c(1,2))
plot(qp.chao.ADG, which = c(1,2))
```
<br>
The quasipoisson distribution fits much better than the Gaussian distribution, so we'll use quasipoisson for further calculations.
<br>
```{r, message=FALSE, warning=FALSE}
summary(qp.chao.ADG)
```
<br>
We'll plot Chao and ADGKG again, to look at the correlation.
<br>
```{r plotting Chao and ADGKG, message=FALSE, warning=FALSE}
par(mfrow = c(1,1))
plot(log(chao) ~ ADGKG, data = meta, ylab = "ln(Chao's richness)")
abline(qp.chao.ADG)
```
<br>
Looking at the graph, there is nog significant correlation between Chao's richness and the Average Daily Gain.
<br>
To test if age and ADG impacts diversity, we'll conduct an ANOVA test.
<br>
```{r, message=FALSE, warning=FALSE}
aov.shannon.all = aov(shannon ~ AgeGroup*ADGKG, data = meta)
summary(aov.shannon.all)
```
<br>
We can see that the interaction between age and ADG does not significantly impact Shannon's diversity, so we'll remove that variable and run the test again.
<br>
```{r, message=FALSE, warning=FALSE}
aov.shannon.all2 = aov(shannon ~ AgeGroup+ADGKG, data = meta)
summary(aov.shannon.all2)
```
<br>
This test tells us that only age impacts Shannon's diversity significantly, but we do not know which age groups differ significantly from eachother. To test this, we can run TukeyHSD with just age.
<br>
```{r TukeyHSD2, message=FALSE, warning=FALSE}
TukeyHSD(aov.shannon.all)
```
<br>
With this test, however, ADGKG is ignored because it's continuous. <br>
We'll run the glm instead.
<br>
```{r glm1, message=FALSE, warning=FALSE}
glm.shannon.all = glm(shannon ~ AgeGroup*ADGKG, data = meta)
summary(glm.shannon.all)
```
<br>
We can see that none of the interaction terms, which are AgeGroup2w:ADGKG and AgeGroup8w:ADGKG, are significant. So we'll remove these, by changing AgeGroup*ADGKG to AgeGroup+ADGKG, and run the glm again.
<br>
```{r glm2, message=FALSE, warning=FALSE}
glm.shannon.all2 = glm(shannon ~ AgeGroup+ADGKG, data = meta)
summary(glm.shannon.all2)
```
<br>
Now that we've removed the interaction terms, the glm model shows age as significant.
<br>
This can also be done with non-normally distributed data, like Chao's richness.
<br>
```{r glm3, message=FALSE, warning=FALSE}
qp.chao.all = glm(chao ~ AgeGroup*ADGKG, data = meta, family = "quasipoisson")
summary(qp.chao.all)
```
<br>
Just like the Shannon's diversity, the interaction terms are not significant, so we'll remove those and run the glm again.
<br>
```{r glm4, message=FALSE, warning=FALSE}
qp.chao.all2 = glm(chao ~ AgeGroup+ADGKG, data = meta, family = "quasipoisson")
summary(qp.chao.all2)
```
<br>
As we can see, age is now significant for richness aswell.
<br>
We sampled the same animals over time, so this is a repeated measures design. We can add this component with (1|animal) in the lmer function.
<br>
```{r, message=FALSE, warning=FALSE}
rm.shannon.all = lmer(shannon ~ AgeGroup+ADGKG + (1|Animal), data = meta)
summary(rm.shannon.all)
```
<br>
Very little, 0.0379, of the variance is explained by the animal random effect. This means that we don't have to include the repeated measures in our final model, but it did need to be checked!
<br>
In conclusion on the alpha diversity: The diversity and richness of the fecal microbiota increases as the dairy cows age. Animal growth, measured by ADG, does not correlate with the diversity or richness of the fecal community.
<br>
<br>
__Looking at the beta diversity__ <br>
Beta diversity looks at the dissimilarity _between_ samples, instead of within a sample, like the alpha diversity.
<br>
First, we'll calculate the non-metric multidimensional scaling using the Bray-Curtis metric. This metric takes into account the presence or absence of OTU's and the abundance of the OTU's that are present in the samples. So, this metric looks at richness and diversity.
<br>
```{r, message=FALSE, warning=FALSE}
BC.nmds = metaMDS(OTU.clean, distance = "bray", k=2, trymax = 1000)
```
<br>
We've reached a convergent solution at around 20 iterations, and the stress is very low, 0.06. That means that 2 axis are sufficient to plot our data.
<br>
We'll plot our data with different colors for each age group.
<br>
```{r, message=FALSE, warning=FALSE}
par(mfrow = c(1,1))
# Creating a blank plot for the nmds
plot(BC.nmds, type = "n", main = "Bray-Curtis")
# Adding the points
points(BC.nmds, display = "sites", pch = 20, col=c("blue", "green", "red"))[meta$AgeGroup] # [Meta$AgeGroup] buiten haakjes gehaald
# Adding a legend
legend(-5.5, 2.5, legend = c("2w", "8w", "1yr"), col=c("green", "red", "blue"), pch = 20)
```
<br>
We can also calculate the nMDS for the Jaccard metric. This metric only looks at the presence or absence of OTU's, so it only looks at richness.
<br>
```{r, message=FALSE, warning=FALSE}
J.nmds = metaMDS(OTU.clean, distance = "jaccard", k=2, trymax = 1000)
```
<br>
With this metric, we've also reached a convergent solution after 20 iterations. The stress is also very low for this metric, 0.06. So, we'll plot this metric with 2 axis aswell.
<br>
```{r}
plot(J.nmds, type = "n", main = "Jaccard")
points(J.nmds, display = "sites", pch = 20, col=c("blue", "green", "red"))[meta$AgeGroup]
legend(-3, 1.5, legend=c("2w", "8w", "1yr"), col = c("green", "red", "blue"), pch = 20)
```
<br>
The values in the plot are somewhat different, but the distributions are very similar. That's because Jaccard = 2xBray-Curtis/(1+Bray-Curtis).
<br>
We can also plot the standard error ellipses of the nMDS data. We'll plot the 99% confidence interval of the Bray-Curtis metric.
<br>
```{r, message=FALSE, warning=FALSE}
plot(BC.nmds, type = "n", main = "Bray-Curtis")
legend(-5.5, 2.5, legend = c("2w", "8w", "1yr"), col = c("green", "red", "blue"), pch = 20)
# Ellipse for 2 weeks
ordiellipse(BC.nmds, groups = meta$AgeGroup, display = "sites", kind = "se", conf = 0.99, label = FALSE, col = "green", draw = "polygon", alpha = 200, show.groups = c("2w"), border = FALSE)
# Ellipse for 8 weeks
ordiellipse(BC.nmds, groups = meta$AgeGroup, display = "sites", kind = "se", conf = 0.99, label = FALSE, col = "red", draw = "polygon", alpha = 200, show.groups = c("8w"), border = FALSE)
# ELLipse for 1 year
ordiellipse(BC.nmds, groups = meta$AgeGroup, display = "sites", kind = "se", conf = 0.99, label = FALSE, col = "blue", draw = "polygon", alpha = 200, show.groups = c("1yr"), border = FALSE)
```
<br>
If the stress is high, over 0.3, it's better to increase to 3 axes.
<br>
We'll first calculate the Bray-Curtis nMDS for a 3-axis plot.
<br>
```{r, message=FALSE, warning=FALSE}
BC.nmds.3D = metaMDS(OTU.clean, distance = "bray", k=3, trymax=1000)
```
<br>
We'll extract the x, y and z for the nMDS, and then plot them.
<br>
```{r, message=FALSE, warning=FALSE}
BCxyz = scores(BC.nmds.3D, display = "sites")
BCxyz
plot_ly(x=BCxyz[,1], y=BCxyz[,2], z=BCxyz[,3], type = "scatter3d", mode = "markers", color = meta$AgeGroup, colors = c("blue", "green", "red"))
```
<br>
3D plots are difficult to interpret in articles, so many authors choose to create two 2D plots instead.
<br>
```{r, message=FALSE, warning=FALSE}
par(mfrow = c(1,2))
# Plotting axis 1 and 2, which are x and y
plot(BCxyz[,1], BCxyz[,2], main = "Bray-Curtis 1:2", pch = 20, col = c("blue", "green", "red"))[meta$AgeGroup]
legend(-5.4, 3, legend = c("2w", "8w", "1yr"), col = c("green", "red", "blue"), pch = 20)
# Plotting axis 1 and 3, which are x and z
plot(BCxyz[,1], BCxyz[,3], main = "Bray-Curtis 1:3", pch = 20, col = c("blue", "green", "red"))[meta$AgeGroup]
```
<br>
The most common type of beta-diversity metric is UniFrac. This metric takes phylogenetic relationships into account, as opposed to Bray-Curtis and Jaccard. So, with UniFrac, samples with different OTU's from the same genus will be more similar than samples with OTU's from different genera. The drawback of UniFrac is that it's sensitive to low abundance OTU's.
<br>
To plot UniFrac, we first have to make a phyloseq object. That means we need OTU.clean, meta and tax.clean data. After we've created the three separate objects, we'll merge them into one.
<br>
```{r making a phyloseq object, message=FALSE, warning=FALSE}
OTU.UF = otu_table(as.matrix(OTU.clean), taxa_are_rows = FALSE)
tax.UF = tax_table(as.matrix(tax.clean))
meta.UF = sample_data(meta)
# Merging them into an object of class phyloseq
physeq = phyloseq(OTU.UF, tax.UF, meta.UF)
```
<br>
To add the phylogenetic component to UniFrac, we need a rooted phylogenetic tree of the OTU's. In this workshop, it had already been calculated and stored in the dataset 'NJ.tree.Rdata'. So, we'll load this data and add it to the physeq object. Then, we'll look at the tree and its components.
<br>
```{r loading and adding the tree, message=FALSE, warning=FALSE}
load("Data/NJ.tree.Rdata") # Downloaded it from GitHub and stored it in the folder "Data"
physeq.tree = merge_phyloseq(physeq, NJ.tree)
physeq.tree
```
<br>
Next, we'll calculate the _weighted_ UniFrac and ordinate it into nMDS.
<br>
```{r, message=FALSE, warning=FALSE}
wUF.ordu = ordinate(physeq.tree, method = "NMDS", distance = "unifrac", weighted = TRUE)
```
<br>
Let's plot the UniFrac nMDS.
<br>
```{r, message=FALSE, warning=FALSE}
par(mfrow = c(1,1))
plot(wUF.ordu, type = "n", main = "Weighted UniFrac")
points(wUF.ordu, pch = 20, display = "sites", col = c("blue", "green", "red"))[meta$AgeGroup]
legend(0.3, 0.15, legend = c("2w", "8w", "1yr"), col = c("green", "red", "blue"), pch = 20)
```
<br>
We can also plot it with ggplot2.
<br>
```{r, message=FALSE, warning=FALSE}
plot_ordination(physeq.tree, wUF.ordu, type = "sites", color = "AgeGroup")+
  scale_colour_manual(values = c("2w"="green", "8w"="red", "1yr"="blue"))+
  theme_bw()+
  ggtitle("Weighted UniFrac")
```
<br>
The Unweighted UniFrac can also be calculated and plotted.
<br>
```{r, message=FALSE, warning=FALSE}
uwUF.ordu = ordinate(physeq.tree, method = "NMDS", distance = "unifrac", weighted = FALSE)
plot_ordination(physeq.tree, uwUF.ordu, type = "sites", color = "AgeGroup")+
  scale_colour_manual(values = c("2w" = "green", "8w" = "red", "1yr" = "blue"))+
  theme_bw()+
  ggtitle("Unweighted UniFrac")
```
<br>
We can also plot the ellipses of the Weighted UniFrac distances.
<br>
```{r, message=FALSE, warning=FALSE}
plot(wUF.ordu, type = "n", main = "Weighted UniFrac")
legend(0.3, 0.15, legend = c("2w","8w","1yr"), col = c("pink", "purple", "blue"), pch = 20)
# Ellipse for 2 weeks
ordiellipse(wUF.ordu, groups = meta$AgeGroup, display = "sites", kind = "se", conf = 0.99, label = FALSE, col = "pink", draw = "polygon", alpha = 200, show.groups = c("2w"), border = FALSE)
# Ellipse for 8 weeks
ordiellipse(wUF.ordu, groups = meta$AgeGroup, display = "sites", kind = "se", conf = 0.99, label = FALSE, col = "purple", draw = "polygon", alpha = 200, show.groups = c("8w"), border = FALSE)
# Ellipse for 1 year
ordiellipse(wUF.ordu, groups = meta$AgeGroup, display = "sites", kind = "se", conf = 0.99, label = FALSE, col = "blue", draw = "polygon", alpha = 200, show.groups = c("1yr"), border = FALSE)
```
<br>
Ellipses can also be plotted with ggplot2, although they look a bit different.
<br>
```{r, message=FALSE, warning=FALSE}
plot_ordination(physeq.tree, wUF.ordu, type = "sites", color = "AgeGroup")+
  scale_colour_manual(values = c("2w" = "pink", "8w" = "purple", "1yr" = "blue"))+
  theme_bw()+
  stat_ellipse()+
  ggtitle("Weighted UniFrac")
```
<br>
We can calculate UniFrac distances with _UniFrac_ and ordinate it for 3-axes with _metaMDS_.
<br>
```{r, message=FALSE, warning=FALSE}
wUF.dist = UniFrac(physeq.tree, weighted = TRUE, normalized = TRUE)
wUF.nmds.3D = metaMDS(wUF.dist, method = "NMDS", k=3)
```
<br>
Then, we'll take out the xyz values and plot them with plotly.
<br>
```{r, message=FALSE, warning=FALSE}
wUFxyz = scores(wUF.nmds.3D, display = "sites")
wUFxyz
plot_ly(x=wUFxyz[,1], y=wUFxyz[,2], z=wUFxyz[,3], type = "scatter3d", mode = "markers", color=meta$AgeGroup, colors=c("pink", "purple", "blue"))
```
<br>
<br>
It is harder to visualize continuous variables in the way we've just visualized categorical values. We can, however, fit these as vectors on the nMDS plots.
<br>
To do that, we'll first fit the variables to our distances. We'll use Bray-Curtis and weighted UniFrac for this, but you can do this with Jaccard aswell and you could also use unweighted UniFrac.
<br>
```{r}
fit.BC = envfit(BC.nmds, meta)
fit.BC
```
<br>
R has automatically fit every variable into the meta table.
If we don't want that, we can tell envfit to only run the variables we want.
<br>
```{r}
fit.BC = envfit(BC.nmds, meta[,c("AgeGroup", "ADGKG")])
fit.BC
```
<br>
We'll repeat this for the weighted UniFrac.
<br>
```{r}
fit.wUF = envfit(wUF.ordu, meta[,c("AgeGroup", "ADGKG")])
fit.wUF
```

