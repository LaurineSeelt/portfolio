---
author: "Laurine Seelt"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
biblio-style: apalike
link-citations: yes
---

# Free space

I had 32 hours to learn something new that will be useful for my internship next year and possibly my job.

I decided I wanted to gain more experience in analysing microbiota data, because I'd like to work with bacteria in my future job. So, I searched the internet for packages and such, and found a course about microbiota analysis that I decided to follow.
<br>
Link to the course: https://rstudio-pubs-static.s3.amazonaws.com/268156_d3ea37937f4f4469839ab6fa2c483842.html
<br>
<br>

__Course: Microbiota analysis in R__

<br>
In this course, we will be looking at the fecal bacterial microbiota of 8 calves at ages 2 weeks, 8 weeks and 1 year old and correlating them with variables such as weight gain, expressed as Average Daily Gain in Kilograms(ADGKG), and gastrointestinal short chain fatty acids, SCFA.
<br>
```{r downloading and loading the packages, message=FALSE, warning=FALSE}
# install.packages("ape")
library(ape)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(gplots)
library(lme4)
library(phangorn)
library(plotly)
library(tidyr)
library(here)
library(vegan)
# install.packages("VennDiagram")
library(VennDiagram)
# Installed Java from: https://www.java.com/en/download/manual.jsp
# Installed Java JDk from: https://www.oracle.com/java/technologies/downloads/#jdk18-windows
# install.packages("rJava")
library(rJava)
# install.packages("venneuler")
# library(venneuler) # R kapt er steeds mee als ik deze wil laden
# if (!require("BiocManager", quietly = TRUE))
    # install.packages("BiocManager")
# BiocManager::install(version = "3.15") # Instead of source("https://bioconductor.org/biocLite.R")
# BiocManager::install("phyloseq") # Instead of biocLite("phyloseq") ?
library(phyloseq)
```

```{r reading in the data, message=FALSE, warning=FALSE}
# Downloaded the data from: https://github.com/kdillmcfarland/workshops_UW_Madison/tree/master/Microbiota_analysis_R/Data
OTU = read.table("Data/example.final.an.unique_list.0.03.norm.shared.txt", 
                 header = TRUE, 
                 sep = "\t")
tax = read.table("Data/example.final.an.unique_list.0.03.cons.taxonomy.txt", 
                 header = TRUE, 
                 sep = "\t")
meta = read.table("Data/example.metadata.txt", 
                  header = TRUE, 
                  row.names = 1, 
                  sep = "\t")
SCFA = read.table("Data/example.SCFA.txt", 
                  header = TRUE, 
                  row.names = 1, 
                  sep = "\t")
```

```{r data wrangling, message=FALSE, warning=FALSE}
# Setting the "Group" column as row names in the OTU dataset
row.names(OTU) = OTU$Group
# Removing the columns that are not OTU counts
OTU.clean = OTU[,-which(names(OTU) %in% c("label", "numOtus", "Group"))]
# Setting the "OTU" column as row names in the taxonomy table
row.names(tax) = tax$OTU
# Removing the OTU's that aren't present in the OTU.clean dataset
tax.clean = tax[row.names(tax) %in% colnames(OTU.clean),]
# Separating the taxonomy table so each level has its own column
tax.clean = separate(tax.clean, 
                     Taxonomy, 
                     into = c("Domain", "Phylum", "Class", "Order", "Family", "Genus", "Species", "Strain"), 
                     sep = ";")
# Removing the "Size", "Strain" and "OTU" columns because these are now row names
tax.clean = tax.clean[,-which(names(tax.clean) %in% c("Size", "Strain", "OTU"))]
# Making sure the three datasets have samples in the same order
OTU.clean = OTU.clean[order(row.names(OTU.clean)),]
meta = meta[order(row.names(meta)),]
SCFA = SCFA[order(row.names(SCFA)),]
# set.seed to make the analysis reproducible
set.seed(8765)
```

__Looking at the alpha diversity__
<br>
Alpha diversity is the diversity _within_ a sample. It looks at richness, which is the _amount_ of OTU's in each sample, and at evenness, which is how evenly the different OTU's are distributed within the sample. <br>
```{r looking at the alpha diversity, message=FALSE, warning=FALSE}
# Creating a 2x2 plot environment so we can see all 4 metrics at once
par(mfrow = c(2,2))
# Plotting the four metrics
hist(meta$shannon, 
     main = "Shannon diversity", 
     xlab = "", 
     breaks = 10)
hist(meta$simpson, 
     main = "Simpson diversity", 
     xlab = "", 
     breaks = 10)
hist(meta$chao, 
     main = "Chao richness", 
     xlab = "", 
     breaks = 15)
hist(meta$ace, 
     main = "ACE richness", 
     xlab = "", 
     breaks = 15)
```
<br>
None of the data are normally distributed. Simpson diversity is very often skewed as seen in this histogram, so we'll calculate 1/Simpson and plot the metrics again.
<br>
```{r, message=FALSE, warning=FALSE}
# Creating a 2x2 environment
par(mfrow = c(2,2))
# Plotting the four metrics again
hist(meta$shannon, 
     main = "Shannon diversity", 
     xlab = "", 
     breaks = 10)
hist(1/meta$simpson, 
     main = "Inverse Simpson diversity", 
     xlab = "", 
     breaks = 10)
hist(meta$chao, 
     main = "Chao richness", 
     xlab = "", 
     breaks = 15)
hist(meta$ace, 
     main = "ACE richness", 
     xlab = "", 
     breaks = 15)
```
<br>
Now the Simpson diversity is distributed similarly to the other richness metrics.
<br>
Next, we'll test the four metrics for normal distribution.
<br>
```{r normality tests, message=FALSE, warning=FALSE}
shapiro.test(meta$shannon)
shapiro.test(1/meta$simpson)
shapiro.test(meta$chao)
shapiro.test(meta$ace)
```
<br>
None of the richness metrics are normally distributed, which was to be expected from the graphs we've seen. So we cannot run any tests that assume the data is normally distributed.
<br>
For illustration purposes, we'll run the ANOVA test with the Shannon's diversity because that's the closest to normally distributed. We'll look at if age impacts the Shannon diversity of the fecal microbiota.
<br>
```{r Anova, message=FALSE, warning=FALSE}
aov.shannon.age = aov(shannon ~ AgeGroup, data = meta)
summary(aov.shannon.age)
```
<br>
We'll run Tukey's honest significance test to do pairwise comparisons between groups and correct for multiple comparisons.
<br>
```{r TukeyHSD, message=FALSE, warning=FALSE}
TukeyHSD(aov.shannon.age)
```
<br>
It's clear that all age groups have significantly different diversity. In a plot, we can clearly see that _diversity_ increases with ages.
<br>
```{r plotting the diversity, message=FALSE, warning=FALSE}
# Re-ordering the groups
meta$AgeGroup.ord = factor(meta$AgeGroup, c("2w", "8w", "1yr"))
# Returning the plot area to 1x1
par(mfrow = c(1,1))
# Plotting the diversity
boxplot(shannon ~ AgeGroup.ord, 
        data = meta, 
        ylab = "Shannon's diversity",
        xlab = "Age group") # Added the xlab myself because it looks better :)
```
<br>
To illustrate some non-parametric tests, we'll use Chao's richness estimate. Age is categorical, so we'll use Kruskal-Wallis.
<br>
```{r Kruskal-Wallis, message=FALSE, warning=FALSE}
kruskal.test(chao ~ AgeGroup, data = meta)
```
<br>
We can also test pairwise within age groups with Wilcoxon Rank Sum Tests.
<br>
```{r Wilcoxon Rank Sum Tests, message=FALSE, warning=FALSE}
pairwise.wilcox.test(meta$chao, meta$AgeGroup, p.adjust.method = "fdr")
```
<br>
Just like the diversity, __richness__ also increases with age.
<br>
```{r plotting the richness, message=FALSE, warning=FALSE}
# Creating a 1x1 plot environment
par(mfrow = c(1,1))
# Plotting the richness
boxplot(chao ~ AgeGroup.ord, data = meta,
        ylab = "Chao richness",
        xlab = "Age group") # Again, added the xlab myself for aesthetics :)
```
<br>
Average Daily Gain is a continuous variable, so we'll use a linear model to visualise it.
<br>
We'll use Shannon's diversity again to run some tests that are meant for normally distributed data. We'll take a look at if the ADG impacts the Shannon diversity of the fecal microbiota.
<br>
```{r glm and lm, message=FALSE, warning=FALSE}
glm.shannon.ADG = glm(shannon ~ ADGKG, data = meta)
summary(glm.shannon.ADG)
```
<br>
This shows that the intercept of our model is signficantly different from 0, bu the slope is not, and the slope is our variable of interest.
<br>
Next, let's plot the glm.
<br>
```{r plotting the glm, message=FALSE, warning=FALSE}
plot(shannon ~ ADGKG, data = meta)
abline(glm.shannon.ADG)
```
<br>
To illustrate non-normally distributed data, we'll use Chao's richness estimate again. We'll first use the Gaussian distribution, but we already know this isn't a good fit.
<br>
```{r plotting Gaussian, message=FALSE, warning=FALSE}
gaussian.chao.adg = glm(chao ~ADGKG, data = meta, family = "gaussian")
par(mfrow = c(1,2))
plot(gaussian.chao.adg, which = c(1,2))
```
<br>
Next, we'll plot the quasipoisson distribuiton.
<br>
```{r plotting quasipoisson, message=FALSE, warning=FALSE}
qp.chao.ADG = glm(chao ~ ADGKG, data = meta, family = "quasipoisson")
par(mfrow = c(1,2))
plot(qp.chao.ADG, which = c(1,2))
```
<br>
The quasipoisson distribution fits much better than the Gaussian distribution, so we'll use quasipoisson for further calculations.
<br>
```{r, message=FALSE, warning=FALSE}
summary(qp.chao.ADG)
```
<br>
We'll plot Chao and ADGKG again, to look at the correlation.
<br>
```{r plotting Chao and ADGKG, message=FALSE, warning=FALSE}
par(mfrow = c(1,1))
plot(log(chao) ~ ADGKG, data = meta, ylab = "ln(Chao's richness)")
abline(qp.chao.ADG)
```
<br>
Looking at the graph, there is nog significant correlation between Chao's richness and the Average Daily Gain.
<br>
To test if age and ADG impacts diversity, we'll conduct an ANOVA test.
<br>
```{r, message=FALSE, warning=FALSE}
aov.shannon.all = aov(shannon ~ AgeGroup*ADGKG, data = meta)
summary(aov.shannon.all)
```
<br>
We can see that the interaction between age and ADG does not significantly impact Shannon's diversity, so we'll remove that variable and run the test again.
<br>
```{r, message=FALSE, warning=FALSE}
aov.shannon.all2 = aov(shannon ~ AgeGroup+ADGKG, data = meta)
summary(aov.shannon.all2)
```
<br>
This test tells us that only age impacts Shannon's diversity significantly, but we do not know which age groups differ significantly from eachother. To test this, we can run TukeyHSD with just age.
<br>
```{r TukeyHSD2, message=FALSE, warning=FALSE}
TukeyHSD(aov.shannon.all)
```
<br>
With this test, however, ADGKG is ignored because it's continuous. <br>
We'll run the glm instead.
<br>
```{r glm1, message=FALSE, warning=FALSE}
glm.shannon.all = glm(shannon ~ AgeGroup*ADGKG, data = meta)
summary(glm.shannon.all)
```
<br>
We can see that none of the interaction terms, which are AgeGroup2w:ADGKG and AgeGroup8w:ADGKG, are significant. So we'll remove these, by changing AgeGroup*ADGKG to AgeGroup+ADGKG, and run the glm again.
<br>
```{r glm2, message=FALSE, warning=FALSE}
glm.shannon.all2 = glm(shannon ~ AgeGroup+ADGKG, data = meta)
summary(glm.shannon.all2)
```
<br>
Now that we've removed the interaction terms, the glm model shows age as significant.
<br>
This can also be done with non-normally distributed data, like Chao's richness.
<br>
```{r glm3, message=FALSE, warning=FALSE}
qp.chao.all = glm(chao ~ AgeGroup*ADGKG, data = meta, family = "quasipoisson")
summary(qp.chao.all)
```
<br>
Just like the Shannon's diversity, the interaction terms are not significant, so we'll remove those and run the glm again.
<br>
```{r glm4, message=FALSE, warning=FALSE}
qp.chao.all2 = glm(chao ~ AgeGroup+ADGKG, data = meta, family = "quasipoisson")
summary(qp.chao.all2)
```
<br>
As we can see, age is now significant for richness aswell.
<br>
We sampled the same animals over time, so this is a repeated measures design. We can add this component with (1|animal) in the lmer function.
<br>
```{r, message=FALSE, warning=FALSE}
rm.shannon.all = lmer(shannon ~ AgeGroup+ADGKG + (1|Animal), data = meta)
summary(rm.shannon.all)
```
<br>
Very little, 0.0379, of the variance is explained by the animal random effect. This means that we don't have to include the repeated measures in our final model, but it did need to be checked!
<br>
In conclusion on the alpha diversity: The diversity and richness of the fecal microbiota increases as the dairy cows age. Animal growth, measured by ADG, does not correlate with the diversity or richness of the fecal community.
<br>
<br>

__Looking at the beta diversity__
<br>
Beta diversity looks at the dissimilarity _between_ samples, instead of within a sample, like the alpha diversity.
<br>
First, we'll calculate the non-metric multidimensional scaling using the Bray-Curtis metric. This metric takes into account the presence or absence of OTU's and the abundance of the OTU's that are present in the samples. So, this metric looks at richness and diversity.
<br>
```{r nMDS Bray-Curtis, message=FALSE, warning=FALSE}
BC.nmds = metaMDS(OTU.clean, distance = "bray", k=2, trymax = 1000)
```
<br>
We've reached a convergent solution at around 20 iterations, and the stress is very low, 0.06. That means that 2 axis are sufficient to plot our data.
<br>
We'll plot our data with different colors for each age group.
<br>
```{r plotting BC nMDS, message=FALSE, warning=FALSE}
par(mfrow = c(1,1))
# Creating a blank plot for the nmds
plot(BC.nmds, type = "n", main = "Bray-Curtis")
# Adding the points
points(BC.nmds, 
       display = "sites", 
       pch = 20, 
       col=c("blue", "green", "red"))[meta$AgeGroup] # [Meta$AgeGroup] buiten haakjes gehaald
# Adding a legend
legend(-5.5, 2.5, 
       legend = c("2w", "8w", "1yr"), 
       col=c("green", "red", "blue"), 
       pch = 20)
```
<br>
We can also calculate the nMDS for the Jaccard metric. This metric only looks at the presence or absence of OTU's, so it only looks at richness.
<br>
```{r nMDS Jaccard, message=FALSE, warning=FALSE}
J.nmds = metaMDS(OTU.clean, distance = "jaccard", k=2, trymax = 1000)
```
<br>
With this metric, we've also reached a convergent solution after 20 iterations. The stress is also very low for this metric, 0.06. So, we'll plot this metric with 2 axis aswell.
<br>
```{r plotting Jaccard nMDS, message=FALSE, warning=FALSE}
plot(J.nmds, 
     type = "n", 
     main = "Jaccard")
points(J.nmds, 
       display = "sites", 
       pch = 20, 
       col=c("blue", "green", "red"))[meta$AgeGroup]
legend(-3, 1.5, 
       legend=c("2w", "8w", "1yr"), 
       col = c("green", "red", "blue"), 
       pch = 20)
```
<br>
The values in the plot are somewhat different, but the distributions are very similar. That's because Jaccard = 2xBray-Curtis/(1+Bray-Curtis).
<br>
We can also plot the standard error ellipses of the nMDS data. We'll plot the 99% confidence interval of the Bray-Curtis metric.
<br>
```{r plotting ellipses, message=FALSE, warning=FALSE}
plot(BC.nmds, 
     type = "n", 
     main = "Bray-Curtis")
legend(-5.5, 2.5, 
       legend = c("2w", "8w", "1yr"), 
       col = c("green", "red", "blue"), 
       pch = 20)
# Ellipse for 2 weeks
ordiellipse(BC.nmds, 
            groups = meta$AgeGroup, 
            display = "sites", 
            kind = "se", 
            conf = 0.99, 
            label = FALSE, 
            col = "green", 
            draw = "polygon", 
            alpha = 200, 
            show.groups = c("2w"), 
            border = FALSE)
# Ellipse for 8 weeks
ordiellipse(BC.nmds, 
            groups = meta$AgeGroup, 
            display = "sites", 
            kind = "se", 
            conf = 0.99, 
            label = FALSE, 
            col = "red", 
            draw = "polygon", 
            alpha = 200, 
            show.groups = c("8w"), 
            border = FALSE)
# ELLipse for 1 year
ordiellipse(BC.nmds, 
            groups = meta$AgeGroup, 
            display = "sites", 
            kind = "se", 
            conf = 0.99, 
            label = FALSE, 
            col = "blue", 
            draw = "polygon", 
            alpha = 200, 
            show.groups = c("1yr"), 
            border = FALSE)
```
<br>
If the stress is high, over 0.3, it's better to increase to 3 axes.
<br>
We'll first calculate the Bray-Curtis nMDS for a 3-axis plot.
<br>
```{r 3D nMDS B-C, message=FALSE, warning=FALSE}
BC.nmds.3D = metaMDS(OTU.clean, distance = "bray", k=3, trymax=1000)
```
<br>
We'll extract the x, y and z for the nMDS, and then plot them.
<br>
```{r BCxyz, message=FALSE, warning=FALSE}
BCxyz = scores(BC.nmds.3D, display = "sites")
BCxyz
plot_ly(x=BCxyz[,1], 
        y=BCxyz[,2], 
        z=BCxyz[,3], 
        type = "scatter3d", 
        mode = "markers", 
        color = meta$AgeGroup, 
        colors = c("blue", "green", "red"))
```
<br>
3D plots are difficult to interpret in articles, so many authors choose to create two 2D plots instead.
<br>
```{r two 2D plots, message=FALSE, warning=FALSE}
par(mfrow = c(1,2))
# Plotting axis 1 and 2, which are x and y
plot(BCxyz[,1], 
     BCxyz[,2], 
     main = "Bray-Curtis 1:2", 
     pch = 20, 
     col = c("blue", "green", "red"))[meta$AgeGroup]
legend(-5.4, 3, 
       legend = c("2w", "8w", "1yr"), 
       col = c("green", "red", "blue"), 
       pch = 20)
# Plotting axis 1 and 3, which are x and z
plot(BCxyz[,1], 
     BCxyz[,3], 
     main = "Bray-Curtis 1:3", 
     pch = 20, 
     col = c("blue", "green", "red"))[meta$AgeGroup]
```
<br>
The most common type of beta-diversity metric is UniFrac. This metric takes phylogenetic relationships into account, as opposed to Bray-Curtis and Jaccard. So, with UniFrac, samples with different OTU's from the same genus will be more similar than samples with OTU's from different genera. The drawback of UniFrac is that it's sensitive to low abundance OTU's.
<br>
To plot UniFrac, we first have to make a phyloseq object. That means we need OTU.clean, meta and tax.clean data. After we've created the three separate objects, we'll merge them into one.
<br>
```{r making a phyloseq object, message=FALSE, warning=FALSE}
OTU.UF = otu_table(as.matrix(OTU.clean), taxa_are_rows = FALSE)
tax.UF = tax_table(as.matrix(tax.clean))
meta.UF = sample_data(meta)
# Merging them into an object of class phyloseq
physeq = phyloseq(OTU.UF, tax.UF, meta.UF)
```
<br>
To add the phylogenetic component to UniFrac, we need a rooted phylogenetic tree of the OTU's. In this workshop, it had already been calculated and stored in the dataset 'NJ.tree.Rdata'. So, we'll load this data and add it to the physeq object. Then, we'll look at the tree and its components.
<br>
```{r loading and adding the tree, message=FALSE, warning=FALSE}
load("Data/Data_raw/NJ.tree.Rdata") # Downloaded it from GitHub and stored it in the folder "Data_raw"
physeq.tree = merge_phyloseq(physeq, NJ.tree)
physeq.tree
```
<br>
Next, we'll calculate the _weighted_ UniFrac and ordinate it into nMDS.
<br>
```{r nMDS wUF, message=FALSE, warning=FALSE}
wUF.ordu = ordinate(physeq.tree, 
                    method = "NMDS", 
                    distance = "unifrac", 
                    weighted = TRUE)
```
<br>
Let's plot the weighted UniFrac nMDS.
<br>
```{r plot wUF nMDS, message=FALSE, warning=FALSE}
par(mfrow = c(1,1))
plot(wUF.ordu, 
     type = "n", 
     main = "Weighted UniFrac")
points(wUF.ordu, 
       pch = 20, 
       display = "sites", 
       col = c("blue", "green", "red"))[meta$AgeGroup]
legend(0.3, 0.15, 
       legend = c("2w", "8w", "1yr"), 
       col = c("green", "red", "blue"), 
       pch = 20)
```
<br>
We can also plot it with ggplot2.
<br>
```{r, message=FALSE, warning=FALSE}
plot_ordination(physeq.tree, 
                wUF.ordu, 
                type = "sites", 
                color = "AgeGroup")+
  scale_colour_manual(values = c("2w"="green", "8w"="red", "1yr"="blue"))+
  theme_bw()+
  ggtitle("Weighted UniFrac")
```
<br>
The Unweighted UniFrac can also be calculated and plotted.
<br>
```{r uwUF nMDS, message=FALSE, warning=FALSE}
uwUF.ordu = ordinate(physeq.tree, 
                     method = "NMDS", 
                     distance = "unifrac", 
                     weighted = FALSE)

plot_ordination(physeq.tree, 
                uwUF.ordu, 
                type = "sites", 
                color = "AgeGroup")+
  scale_colour_manual(values = c("2w" = "green", "8w" = "red", "1yr" = "blue"))+
  theme_bw()+
  ggtitle("Unweighted UniFrac")
```
<br>
We can also plot the ellipses of the Weighted UniFrac distances.
<br>
```{r, message=FALSE, warning=FALSE}
plot(wUF.ordu, 
     type = "n", 
     main = "Weighted UniFrac")
legend(0.3, 0.15, 
       legend = c("2w","8w","1yr"), 
       col = c("green", "red", "blue"), 
       pch = 20)
# Ellipse for 2 weeks
ordiellipse(wUF.ordu, 
            groups = meta$AgeGroup, 
            display = "sites", 
            kind = "se", 
            conf = 0.99, 
            label = FALSE, 
            col = "green", 
            draw = "polygon", 
            alpha = 200, 
            show.groups = c("2w"), 
            border = FALSE)
# Ellipse for 8 weeks
ordiellipse(wUF.ordu, 
            groups = meta$AgeGroup, 
            display = "sites", 
            kind = "se", 
            conf = 0.99, 
            label = FALSE, 
            col = "red", 
            draw = "polygon", 
            alpha = 200, 
            show.groups = c("8w"), 
            border = FALSE)
# Ellipse for 1 year
ordiellipse(wUF.ordu, 
            groups = meta$AgeGroup, 
            display = "sites", 
            kind = "se", 
            conf = 0.99, 
            label = FALSE, 
            col = "blue", 
            draw = "polygon", 
            alpha = 200, 
            show.groups = c("1yr"), 
            border = FALSE)
```
<br>
Ellipses can also be plotted with ggplot2, although they look a bit different.
<br>
```{r, message=FALSE, warning=FALSE}
plot_ordination(physeq.tree, 
                wUF.ordu, 
                type = "sites", 
                color = "AgeGroup")+
  scale_colour_manual(values = c("2w" = "green", "8w" = "red", "1yr" = "blue"))+
  theme_bw()+
  stat_ellipse()+
  ggtitle("Weighted UniFrac")
```
<br>
We can calculate UniFrac distances with _UniFrac_ and ordinate it for 3-axes with _metaMDS_.
<br>
```{r UFdist, message=FALSE, warning=FALSE}
wUF.dist = UniFrac(physeq.tree, weighted = TRUE, normalized = TRUE)
wUF.nmds.3D = metaMDS(wUF.dist, method = "NMDS", k=3)
```
<br>
Then, we'll take out the xyz values and plot them with plotly.
<br>
```{r wUFxyz, message=FALSE, warning=FALSE}
wUFxyz = scores(wUF.nmds.3D, display = "sites")
wUFxyz
plot_ly(x=wUFxyz[,1], 
        y=wUFxyz[,2], 
        z=wUFxyz[,3], 
        type = "scatter3d", 
        mode = "markers", 
        color=meta$AgeGroup, 
        colors=c("pink", "purple", "blue"))
```
<br>
<br>
It is harder to visualize continuous variables in the way we've just visualized categorical values. We can, however, fit these as vectors on the nMDS plots.
<br>
To do that, we'll first fit the variables to our distances. We'll use Bray-Curtis and weighted UniFrac for this, but you can do this with Jaccard aswell and you could also use unweighted UniFrac.
<br>
```{r fitting BC, message=FALSE, warning=FALSE}
fit.BC = envfit(BC.nmds, meta)
fit.BC
```
<br>
R has automatically fit every variable into the meta table.
If we don't want that, we can tell envfit to only run the variables we want.
<br>
```{r fitting BC 2, message=FALSE, warning=FALSE}
fit.BC = envfit(BC.nmds, meta[,c("AgeGroup", "ADGKG")])
fit.BC
```
<br>
We'll repeat this for the weighted UniFrac.
<br>
```{r fitting wUF, message=FALSE, warning=FALSE}
fit.wUF = envfit(wUF.ordu, meta[,c("AgeGroup", "ADGKG")])
fit.wUF
```
<br>
We can plot the 2D nMDS with an arrow for the ADG, eventho the ADG isn't a significant variable. Thus, you wouldn't use this figure in a publication or such. We'll do this with the Bray-Curtis dissimilarity.
<br>
```{r plotting the fitted BC, message=FALSE, warning=FALSE}
plot(BC.nmds, 
     type = "n", 
     main = "Bray-Curtis")
points(BC.nmds, 
       pch = 20, 
       display = "sites", 
       col = c("blue", "green", "red"))[meta$AgeGroup]
legend(-6, 2, 
       legend = c("2w", "8w", "1yr"), 
       col = c("green", "red", "blue"), 
       pch = 20)
plot(fit.BC, col = "black") # Adding the fitted variables
```
<br>
We can also only plot variables with p < 0.05. That'd mean we'd only see the centroids.
<br>
```{r plotting the significant BC, message=FALSE, warning=FALSE}
plot(BC.nmds, 
     type = "n", 
     main = "Bray-Curtis")
points(BC.nmds, 
       pch = 20, 
       display = "sites", 
       col = c("blue", "green", "red"))[meta$AgeGroup]
legend(-6, 2, 
       legend = c("2w", "8w", "1yr"), 
       col = c("green", "red", "blue"), 
       pch = 20)
plot(fit.BC, col = "black", p.max = 0.05)
```
<br>
We can also plot the weighted UniFrac.
<br>
```{r plotting wUF, message=FALSE, warning=FALSE}
plot(wUF.ordu, 
     type = "n", 
     main = "Weighted UniFrac")
points(wUF.ordu, 
       pch = 20, 
       display = "sites", 
       col = c("blue", "green", "red"))[meta$AgeGroup]
legend(.3, .15, 
       legend = c("2w", "8w", "1yr"), 
       col = c("green", "red", "blue"), 
       pch = 20)
plot(fit.wUF, col = "black")
```
<br>
If we fit the OTU.clean data frame to the nMDS, we can add arrows for specific OTU's in the plot. <br>
If an OTU arrow goes in the same direction as an age group centroid, that OTU tends to increase in abundance in that age group. <br>
Conversely, if an OTU arrow moves in the opposite direction of an age group centroid, that OTU probably decreases in abundance in that age group. <br>
We'll only fit the first 10 OTU's from our table, because it takes a long time. <br>
Then, we'll only plot the significant arrows.
<br>
```{r fitting OTUs, message=FALSE, warning=FALSE}
fit.BC.OTU = envfit(BC.nmds, OTU.clean[,1:10])
fit.BC.OTU
plot(BC.nmds, 
     type = "n", 
     main = "Bray-Curtis")
points(BC.nmds, 
       pch = 20, 
       display = "sites", 
       col = c("blue", "green", "red"))[meta$AgeGroup]
legend(-6, -1.1, 
       legend = c("2w", "8w", "1yr"), 
       col = c("green", "red", "blue"), 
       pch = 20)
plot(fit.BC.OTU, col = "black", p.max = 0.05)
```
<br>
We can also plot summed genera or family groups of OTU's.
<br>
```{r plotting rumino, message=FALSE, warning=FALSE}
# Extracting all the OTU's within the Ruminococcus genus
OTU.rumino = OTU.clean[,tax.clean$Genus == "g__Ruminococcus"]
# Summing the abundances of the OTU's into one variable/column
OTU.rumino$Rumino.sum = rowSums(OTU.rumino)
# Fitting the Ruminococceae group
fit.BC.rumino = envfit(BC.nmds, OTU.rumino$Rumino.sum)
fit.BC.rumino
# Plotting it
plot(BC.nmds, 
     type = "n", 
     main = "Bray-Curtis")
points(BC.nmds, 
       pch = 20, 
       display = "sites", 
       col = c("blue", "green", "red"))[meta$AgeGroup]
legend(-6, -1.1, 
       legend = c("2w", "8w", "1yr"), 
       col = c("green", "red", "blue"), 
       pch = 20)
# Adding the fitted variables
plot(fit.BC.rumino, col = "black", labels = c("Ruminococcus"))
```
<br>
We can test for significant differences between samples with the permutational analysis of variance, PERMANOVA, or analysis of similarity, ANOSIM. Both test if the overall microbial community differs by your variable of interest. <br>
We can run these tests with Bray-Curtis, Jaccard, unweighted UniFrac and/or weighted UniFrac. <br>
If the variable is significant for Bray-Curtis/weighted UniFrac but not for Jaccard/unweighted UniFrac, that means the groups tend to have the same OTU's(richness), but different abundances of those OTU's(diversity). <br>
If the variables are significant for Bray-Curtis/Jaccard but not for unweighted/weighted UniFrac, that means the samples have different specific OTU's but similar taxa. <br>
For Bray-Curtis and Jaccard, we can calculate the distances and run PERMANOVA.
<br>
```{r PERMANOVA Bray-Curtis, message=FALSE, warning=FALSE}
BC.dist = vegdist(OTU.clean, distance = "bray")
# adonis(BC.dist ~ AgeGroup*ADGKG, data = meta, permutations = 1000)
```

```{r PERMANOVA Jaccard, message=FALSE, warning=FALSE}
J.dist = vegdist(OTU.clean, distance = "jaccard")
# adonis(J.dist ~ AgeGroup*ADGKG, data = meta, permutations = 1000)
```
<br>
For both Bray-Curtis and Jaccard, the interaction isn't significant. So we'll run PERMANOVA again, without the interaction component.
<br>
```{r PERMANOVA Bray-Curtis 2, message=FALSE, warning=FALSE}
# adonis(BC.dist ~ AgeGroup+ADGKG, data = meta, permutations = 1000)
```
<br>
```{r PERMANOVA Jaccard 2, message=FALSE, warning=FALSE}
# adonis(J.dist ~ AgeGroup+ADGKG, data = meta, permutations = 1000)
```
<br>
We'll also calculate the distances for weighted and unweighted UniFrac and then run PERMANOVA.
<br>
```{r PERMANOVA wUF, message=FALSE, warning=FALSE}
wUF.dist = UniFrac(physeq.tree, weighted = TRUE, normalized = TRUE)
# adonis(wUF.dist ~ AgeGroup*ADGKG, data = meta, permutations = 1000)
```
<br>
```{r PERMANOVA uwUF, message=FALSE, warning=FALSE}
uwUF.dist = UniFrac(physeq.tree, weighted = FALSE, normalized = TRUE)
# adonis(uwUF.dist ~ AgeGroup*ADGKG, data = meta, permutations = 1000)
```
<br>
We'll remove the non-significant interaction terms for both of these aswell.
<br>
```{r PERMANOVA wUF 2, message=FALSE, warning=FALSE}
# adonis(wUF.dist ~ AgeGroup+ADGKG, data = meta, permutations = 1000)
```
<br>
```{r PERMANOVA uwUF 2, message=FALSE, warning=FALSE}
# adonis(uwUF.dist ~ AgeGroup+ADGKG, data = meta, permutations = 1000)
```
<br>
If your group sizes are very different, you can use ANOSIM instead of PERMANOVA. ANOSIM does have quite some limitations; you can only test one variable, so no interaction, and it can only be used for categorical variables. <br>
We'll run it for Bray-Curtis to demonstrate.
<br>
```{r ANOSIM Bray-Curtis, message=FALSE, warning=FALSE}
anosim(BC.dist, meta$AgeGroup, permutations = 1000)
```
<br>
The Mantel test, tests if two distance matrices co-vary. So, it tests if the data in matrix 1 changes in the same way as the data in matrix 2.
<br>
First, we'll subset our OTU table to the samples that we also have SCFA information about.
<br>
```{r subsetting the OTU table, message=FALSE, warning=FALSE}
OTU.SCFA = OTU.clean[row.names(OTU.clean) %in% paste(row.names(SCFA), ".F", sep = ""),]
```
<br>
Then, we'll calculate the distances for each matrix and run the Mantel.
<br>
```{r calculating distances & running Mantel, message=FALSE, warning=FALSE}
dist1 = vegdist(OTU.SCFA)
dist2 = vegdist(SCFA)
mantel(dist1, dist2)
```
<br>
We can see that the overall OTU table and SCFA tables do not co-vary.
<br>
Sometimes it will be clear from nMDS that one group tends to vary more than other groups. We can test this with multivariate homogeneity of group dispersion. We'll use Bray-Curtis to demonstrate this. <br>
First we'll calculate the dispersion in each group. Then, we'll perform an ANOVA-like test to determine if the variances differ by groups.
<br>
```{r calculating dispersion & running ANOVA, message=FALSE, warning=FALSE}
disp.age = betadisper(BC.dist, meta$AgeGroup)
permutest(disp.age, pairwise = TRUE, permutations = 1000)
```
<br>
If we also look at the Bray-Curtis plot we made earlier, we can conclude that 2 and 8 week old calves have a similar variability in their fecal microbiota. They also have more variable fecal microbiotas than 1 year old heifers.

__OTU's that differ by__
<br>
The SIMPER function gives us a list of the OTU's that cumulatively explain more than 70% of the variation between samples. In our case, we can use this function to see if specific OTU's differ between the three age groups, even if the overall microbiota doesn't differ between the age groups.
<br>
```{r Simper, message=FALSE, warning=FALSE}
simper(OTU.clean, meta$AgeGroup, permutations = 1000)
```
<br>
These OTU's contribute to the Bray-Curtis dissimilarity, but they're not necessarily significantly different. To test if an OTU is significantly different, we can test it with the Kruskal-Wallis test.
<br>
```{r K-W OTU00001, message=FALSE, warning=FALSE}
kruskal.test(OTU.clean$Otu00001 ~ meta$AgeGroup)
```
<br>
The p-value for OTU00001 is much lower than 0.05, so this OTU is significantly different between age groups.
<br>
```{r K-W OTU00017, message=FALSE, warning=FALSE}
kruskal.test(OTU.clean$Otu00017 ~ meta$AgeGroup)
```
<br>
The p-value for OTU 00017 is bigger than 0.05, so this OTU is not significantly different between age groups.
<br>
I downloaded the simper_pretty and R_krusk scripts from https://github.com/asteinberger9/seq_scripts and stored them in the folder "R". <br>
The simper_pretty script performs the SIMPER function for all comparisons of interest in a data set. The output of this script is a .csv document. <br>
The R_krusk script performs the non-parametric Kruskal-Wallis test on each OTU in the .csv file from the simper_pretty script. 
<br>
```{r simper_pretty and R_krusk, message=FALSE, warning=FALSE, eval=FALSE}
source("R/simper_pretty.R") # deleted the last line of this script because it kept throwing an error otherwise
source("R/R_krusk.R")

simper.pretty(OTU.clean, meta, c('AgeGroup'), perc_cutoff=1, low_cutoff = 'y', low_val=0.01, 'Age')
simper.results = data.frame(read.csv("Data/Age_clean_simper.csv"))
kruskal.pretty(OTU.clean, meta, simper.results, c('AgeGroup'), 'Age', tax)

#Importing the K-W results
KW.results = data.frame(read.csv("Data/Age_krusk_simper.csv"))
#Removing non-significant results
KW.results.signif = KW.results[KW.results$fdr_krusk_p.val < 0.05,]
#Ordering the results by OTU#
KW.results.signif = KW.results.signif[with(KW.results.signif, order(OTU)),]
head(KW.results.signif)
```
<br>
We can see that there are several OTU's that differ significantly by age group. <br>
We'll look at OTU1 as relative abundance.
<br>
```{r OTU1 relative, message=FALSE, warning=FALSE}
# Abundance berekenen
abund = OTU.clean/rowSums(OTU.clean)*100
# Plotting the abundances
boxplot(abund$Otu00001 ~ meta$AgeGroup, ylab = "% Relative abundance", main = "OTU1")
```
<br>
Looking at the graph, together this the results from the Kruskal-Wallis test, we can say that OTU1 is significantly less abundant in 1-year-old animals than in 2- or 8-week-old animals.
<br>
<br>
To investigate continuous variables, like Average Daily Gain in our case, we cannot use SIMPER.
You could approach the continuous variable as a correlation. In general only strong correlations, with r being greater than 0.5 or smaller than -0.5, should be reported. We'll use Kendall-Tau to do this because it doesn't assume linearity or normality.
<br>
To decrease the number of OTU's tested, we'll correlate ADG with OTU's that have at least 5% relative abundance in at least one sample.
<br>
```{r ADG correlation, message=FALSE, warning=FALSE}
# Subsetting the OTU's with 5% abundance
OTU.abund = OTU.clean[, apply(abund, MARGIN = 2, function(x) any(x > 5))]

cor.kendall = cor(OTU.abund, meta$ADGKG, method = "kendall")
cor.kendall
```
<br>
There aren't any correlations greater than 0.5 or smaller than -0.5, so there aren't any significant correlations.
<br>
Now, we'll correlate SCFA's with OTU's that have at least 1% relative abundance in at least one sample. Obviously, we'll only use samples for which we have SCFA data.
<br>
```{r SCFA correlation, message=FALSE, warning=FALSE}
# Calculating the abundances
abund.SCFA = OTU.SCFA/rowSums(OTU.SCFA)*100

# Subsetting the OTU's with the cutoff of 1% abundance
OTU.SCFA.abund = OTU.SCFA[, apply(abund.SCFA, MARGIN = 2, function(x) any(x > 1))]

# Calculating the correlation
cor.kendall = cor(OTU.SCFA.abund, SCFA, method = "kendall")
cor.kendall
```
<br>
This table is very large, so we'll write it to a table in the project folder.
<br>
```{r writing a table, message=FALSE, warning=FALSE}
write.table(cor.kendall, file = "cor_kendall.csv", sep = ",")
cor_kendall <- read.csv("cor_kendall.csv")
```
<br>
Some OTU's have a strong correlation with a SCFA. For example, OTU00021 and OTU00025 have a strong correlation with the SCFA Formate. We'll show this in a plot.
<br>
```{r plotting the correlation, message=FALSE, warning=FALSE}
par(mfrow = c(1,2))
plot(abund.SCFA$Otu00021 ~ SCFA$Formate, 
     xlab = "Formate (mM)", 
     ylab = "Relative abundance, %", 
     main = "OTU21")
plot(abund.SCFA$Otu00025 ~ SCFA$Formate, 
     xlab = "Formate (mM)", 
     ylab = "Relative abundance, %", 
     main = "OTU25")
```
<br>
We don't have a lot of data points, so we can't draw strong conclusions from this. However, we can further test the OTU's that correlate strongly with a SCFA. To do this, we will assume a normal distribution.
<br>
```{r glm for OTU21 & OTU25 with formate, message=FALSE, warning=FALSE}
OTU21.Formate = glm(OTU.SCFA$Otu00021 ~ SCFA$Formate)
summary(OTU21.Formate)
OTU25.Formate = glm(OTU.SCFA$Otu00025 ~ SCFA$Formate)
summary(OTU25.Formate)
```
<br>
Turns out, both OTU's don't differ significantly with Formate concentration, eventhough they had very strong Kendall correlations. 
<br>
<br>
To visualize all the phyla in our samples, we could make an additive bar chart.
<br>
```{r additive bar chart, message=FALSE, warning=FALSE}
plot_bar(physeq.tree, fill = "Phylum")
```
<br>
To make this graph a bit more readable, we can group it by age.
<br>
```{r bar chart with age, message=FALSE, warning=FALSE}
plot_bar(physeq.tree, x = "AgeGroup", fill = "Phylum")
```
<br>
To make it even clearer, we can remove the lines between the OTU's.
<br>
```{r another bar chart, message=FALSE, warning=FALSE}
plot_bar(physeq.tree, x = "AgeGroup", fill = "Phylum") + 
  geom_bar(aes(color = Phylum, fill = Phylum), stat = "identity", position = "stack")
```
<br>
We can also modify the bar chart to only show the five most abundant phyla for each age group.
<br>
```{r top 5 bar chart, message=FALSE, warning=FALSE}
# Sorting the phyla by abundance and picking the top 5
top5P.names = sort(tapply(taxa_sums(physeq.tree), tax_table(physeq.tree)[, "Phylum"], sum), TRUE)[1:5]

# Cutting the physeq.tree down to the top 10 Phyla
top5P = subset_taxa(physeq.tree, Phylum %in% names(top5P.names))

# Plotting the top 5 phyla
plot_bar(top5P, x = "AgeGroup", fill = "Phylum") + 
  geom_bar(aes(color = Phylum, fill = Phylum), stat = "identity", position = "stack")
```
<br>
We can also plot several bar charts next to each other, separated by the phyla.
<br>
```{r separated bar charts, message=FALSE, warning=FALSE}
plot_bar(top5P, x = "AgeGroup", fill = "Phylum", facet_grid = ~Phylum) + geom_bar(aes(color = Phylum, fill = Phylum), stat = "identity", position = "stack")
```
<br>
We can also plot phylogenetic trees. For now, we'll look at the genus _Prevotella_. <br> To do this, we firtt need to make a subset with only the _Prevotella_ genus.
<br>
```{r subset Prevotella, message=FALSE, warning=FALSE}
prevotella = subset_taxa(physeq.tree, Genus == "g__Prevotella")
```
<br>
To see if this worked, we can compare the number of taxa in our new subset and the original physeq tree.
<br>
```{r comparison, message=FALSE, warning=FALSE}
physeq.tree
prevotella
```
<br>
Next, we can plot the OTUs on a tree.
<br>
```{r OTU tree, message=FALSE, warning=FALSE}
plot_tree(prevotella, plot.margin = 0.5, ladderize = TRUE)
```
<br>
This tree isn't very useful or readable yet. We can add colors for the age groups, size the dots according to the OTU abundance and species level labels for the OTUs.
<br>
```{r better OTU tree, message=FALSE, warning=FALSE}
plot_tree(prevotella, color = "AgeGroup", label.tips = "Species", size = "abundance", plot.margin = 0.5, ladderize = TRUE)
```
<br>
We can also visualize the abundance in a heatmap. To make a heatmap a bit readable, we'll only use the 20 most abundant OTUs.
<br>
```{r top 20 most abundant OTUs, message=FALSE, warning=FALSE}
# Sorting the OTUs by abundance and picking the top 20
top20OTU.names = names(sort(taxa_sums(physeq.tree), TRUE)[1:20])

# Cutting down the physeq.tree to only the top 10 Phyla
top20OTU = prune_taxa(top20OTU.names, physeq.tree)

# We can see we now only have 20 taxa
top20OTU
```
<br>
Now, we can make a heatmap.
<br>
```{r heatmap top 20, message=FALSE, warning=FALSE}
plot_heatmap(top20OTU)
```
<br>
We can also group it by age.
<br>
```{r heatmap top 20 grouped, message=FALSE, warning=FALSE}
plot_heatmap(top20OTU, sample.label = "AgeGroup", sample.order = "AgeGroup")
```
<br>
We can also label the OTU taxa.
<br>
```{r heatmap top 20 labelled, message=FALSE, warning=FALSE}
plot_heatmap(top20OTU, 
             sample.label = "AgeGroup", 
             sample.order = "AgeGroup", 
             taxa.label = "Genus")
```
<br>
We can also group OTUs in the same Phyla.
<br>
```{r heatmap top 20 grouped OTUs, message=FALSE, warning=FALSE}
plot_heatmap(top20OTU, 
             sample.label = "AgeGroup", 
             sample.order = "AgeGroup", 
             taxa.label = "Genus", 
             taxa.order = "Phylum")
```
<br>
We can also change the colors.
<br>
```{r heatmap diff colors, message=FALSE, warning=FALSE}
plot_heatmap(top20OTU, 
             sample.label = "AgeGroup", 
             sample.order = "AgeGroup", 
             taxa.label = "Genus", 
             taxa.order = "Phylum", 
             low = "white", 
             high = "purple", 
             na.value = "grey")
```
<br>
We cal also plot the Bray-Curtis dissimilarity in a heatmap.
<br>
```{r BC heatmap, message=FALSE, warning=FALSE}
plot_heatmap(top20OTU, "NMDS", "bray", title = "Bray-Curtis")
```
<br>
We can also use heatmaps to show the distance between samples, also known as the beta-diversity. We can use the distance matrices as input for this heatmap. We'll use a gplots command for this.
<br>
```{r BC beta heatmap, message=FALSE, warning=FALSE}
heatmap.2(as.matrix(BC.dist))
```
<br>
We can also use this for UniFrac.
<br>
```{r UniFrac heatmap, message=FALSE, warning=FALSE}
heatmap.2(as.matrix(wUF.dist))
```
<br>
We can also change the colors of the heatmap.
<br>
```{r rainbow BC heatmap, message=FALSE, warning=FALSE}
rc <- rainbow(nrow(as.matrix(BC.dist)), start = 0, end = 0.9)
heatmap.2(as.matrix(BC.dist), col = rc)
```
<br>
Next, we'll make Venn diagrams of the samples 5017.2w.F, 5017.8w.F and 5017.1yr.F. <br>
First, we'll make a list of the OTUs that occur in the three samples.
```{r OTU list of 5017, message=FALSE, warning=FALSE}
OTU.5017.2w = colnames(OTU.clean["5017.2w.F", apply(OTU.clean["5017.2w.F",], MARGIN = 2, function(x) any(x > 0))])
OTU.5017.8w = colnames(OTU.clean["5017.8w.F", apply(OTU.clean["5017.8w.F",], MARGIN = 2, function(x) any(x > 0))])
OTU.5017.1yr = colnames(OTU.clean["5017.1yr.F", apply(OTU.clean["5017.1yr.F",], MARGIN = 2, function(x) any(x > 0))])
```
<br>
Now we can use these three lists to make a Venn diagram.
<br>
```{r Venn diagram 5017, message=FALSE, warning=FALSE}
venn(list(OTU.5017.2w, OTU.5017.8w, OTU.5017.1yr))
```
<br>
We can also make a Venn diagram for the three age groups.
<br>
```{r OTU list of the three age groups, message=FALSE, warning=FALSE}
OTU.2w = colnames(OTU.clean[meta$AgeGroup == "2w", apply(OTU.clean[meta$AgeGroup == "2w",], MARGIN = 2, function(x) any(x > 0))])
OTU.8w = colnames(OTU.clean[meta$AgeGroup == "8w", apply(OTU.clean[meta$AgeGroup == "8w",], MARGIN = 2, function(x) any(x > 0))])
OTU.1yr = colnames(OTU.clean[meta$AgeGroup == "1yr", apply(OTU.clean[meta$AgeGroup == "1yr",], MARGIN = 2, function(x) any(x > 0))])
```
<br>
```{r Venn diagram age groups, message=FALSE, warning=FALSE}
venn(list(OTU.2w, OTU.8w, OTU.1yr))
```
<br>
We can make this Venn diagram a lot prettier!
<br>
```{r prettier Venn diagram, message=FALSE, warning=FALSE}
draw.triple.venn(area1 = 385+58+71+320, 
                 area2 = 801+190+320+71, 
                 area3 = 3177+190+58+71, 
                 n12 = 320+17, 
                 n23 = 190+71, 
                 n13 = 58+71, 
                 n123 = 17, 
                 category = c("2w", "8w", "1yr"), 
                 lty = "blank", 
                 fill = c("green", "red", "blue"))
# This doesn't show the Venn diagram, I think because I can't load the venneuler package?
```
<br>
With the venneuler package, we can scale the circles to be proportional to the the total number of OTUs in that group.
<br>
```{r scaled Venn diagram, message=FALSE, warning=FALSE, eval=FALSE}
age.venn = venneuler(c(
  'A' = 385+58+71+320, 
  'B' = 801+190+320+17, 
  'C' = 3177+190+58+17, 
  'A&B' = 320+71, 
  'B&C' = 190+71, 
  'A&C' = 58+71, 
  'A&B&C' = 71))

age.venn$labels = c("2w", "8w", "1yr")

plot(age.venn)
```
<br>
We can also plot the distances between the OTUs as a network. We'll do this with the Prevotella subset to keep it readable.
<br>
```{r Prevotella network, message=FALSE, warning=FALSE}
plot_net(prevotella, color = "Species", type = "taxa")
```
<br>
We can also plot the beta-diversity as a network. The lines represent the distances between the samples in that case.
<br>
```{r beta-diversity network, message=FALSE, warning=FALSE}
plot_net(physeq.tree, color = "AgeGroup", distance = "bray")
```
<br>
<br>
Ideally you'd export the figures you want to use for a publication as PostScript (.ps) or PDF (.pdf). <br>
For PostScript, we'll use the following code.
<br>
```{r PNG, message=FALSE, warning=FALSE, eval=FALSE}
postscript("Fig1.ps", width = 7, height = 3, horizontal = FALSE, colormodel = "rgb", family = "ArialMT")
 
layout(matrix(c(1,2), 1, 2), widths=c(3,2), heights=c(1,1))
 
plot(BC.nmds, 
     type="n", 
     main="Bray-Curtis")
points(BC.nmds, 
       display="sites", 
       pch=20, 
       col=c("blue", "green", "red")[meta$AgeGroup])
 
boxplot(shannon ~ AgeGroup.ord, 
        data=meta, 
        main="Diversity", 
        ylab="Shannon's diversity", 
        col=c("green", "red", "blue"))
 
dev.off()
```
<br>
To export a PDF, we'll use the following code.
<br>
```{r PDF, message=FALSE, warning=FALSE, eval=FALSE}
pdf("Fig1.pdf", 
    width = 7, 
    height = 3,  
    colormodel = "rgb", 
    family = "ArialMT")
 
layout(matrix(c(1,2), 1, 2), widths=c(3,2), heights=c(1,1))
 
plot(BC.nmds, 
     type="n", 
     main="Bray-Curtis")
points(BC.nmds, 
       display="sites", 
       pch=20, col=c("blue", "green", "red")[meta$AgeGroup])
 
boxplot(shannon ~ AgeGroup.ord, 
        data=meta, main="Diversity", 
        ylab="Shannon's diversity", 
        col=c("green", "red", "blue"))
 
dev.off()
```
<br>
Lastly, we can export is as a PNG with the following code.
<br>
```{r PNG export, message=FALSE, warning=FALSE, eval=FALSE}
png("Fig1.png", 
    width = 7, 
    height = 3, 
    units='in', 
    res=300)
 
layout(matrix(c(1,2), 1, 2), widths=c(3,2), heights=c(1,1))
 
plot(BC.nmds, 
     type="n", 
     main="Bray-Curtis")
points(BC.nmds, 
       display="sites", 
       pch=20, 
       col=c("blue", "green", "red")[meta$AgeGroup])
 
boxplot(shannon ~ AgeGroup.ord, 
        data=meta, 
        main="Diversity", 
        ylab="Shannon's diversity", c
        ol=c("green", "red", "blue"))
 
dev.off()
```

__End of tutorial__

Now, to show you what I've learned, I have written a bit of my own code aswell.
<br>
In the tutorial, we tested if the interaction between age and ADG significantly impacted Shannon's diversity, which it didn't. I will test if the interaction between age and ADG significantly impacts ACE richness.
<br>
```{r glm ace, message=FALSE, warning=FALSE}
qp.ace = glm(ace ~ AgeGroup*ADGKG, data = meta, family = "quasipoisson")
summary(qp.ace)
```
<br>
The interactions aren't significant, so we'll remove these and run glm again.
<br>
```{r glm ace 2, message=FALSE, warning=FALSE}
qp.ace2 = glm(ace ~ AgeGroup+ADGKG, data = meta, family = "quasipoisson")
summary(qp.ace2)
```
<br>
We can see that now, both age groups have become significant. That means that for both age groups, the difference with 1 year is significant when it comes to ACE richness.
<br>
<br>
In the tutorial, we plotted the genus _Reminococcus_ in a plot with the Bray-Curtis dissimilarity for the three age groups. I will plot the genus _Clostridium_ and _Akkermansia_ in a similar plot.
<br>
```{r Clostridium & Akkermansia, message=FALSE, warning=FALSE}
OTU.clostridium = OTU.clean[,tax.clean$Genus == "g__Clostridium"]
OTU.akkermansia = OTU.clean[,tax.clean$Genus == "g__Akkermansia"]

# Summing the abundance of both groups into one variable for each group
OTU.clostridium$clostridium.sum = rowSums(OTU.clostridium)
OTU.akkermansia$akkermansia.sum = rowSums(OTU.akkermansia)

# Then, we'll fit both groups
fit.BC.Clostridium = envfit(BC.nmds, OTU.clostridium$clostridium.sum)
fit.BC.Akkermansia = envfit(BC.nmds, OTU.akkermansia$akkermansia.sum)

# Lastly, we'll plot both groups
plot(BC.nmds, 
     type = "n", 
     main = "Bray-Curtis")
points(BC.nmds, 
       pch = 20, 
       display = "sites", 
       col = c("blue", "green", "red"))[meta$AgeGroup]
legend(-6, -1.1, 
       legend = c("2w", "8w", "1yr"), 
       col = c("green", "red", "blue"), 
       pch = 20)
plot(fit.BC.Clostridium, 
     col = "black", 
     labels= c("Clos"))
plot(fit.BC.Akkermansia, 
     col = "black", 
     labels = c("Akk"))
```
<br>
In the tutorial, we calculated the dispersion/variance for the Bray-Curtis dissimilarity and then plotted it. Here, I did this for the Jaccard index.
<br>
So, I first calculated the dispersion/variances for each group.
<br>
```{r variance Jaccard, message=FALSE, warning=FALSE}
disp.j.age = betadisper(J.dist, meta$AgeGroup)
```
<br>
Then, I performed an ANOVA-like test to see if the variances differ by group.
```{r ANOVA-like Jaccard, message=FALSE, warning=FALSE}
permutest(disp.j.age, pairwise = TRUE, permutations = 1000)
```
<br>
Then, I plotted the Jaccard index for the three age groups.
<br>
```{r Jaccard plot, message=FALSE, warning=FALSE}
plot(J.nmds, 
     type="n", 
     main="Jaccard index",
     ylim = c(-3, 3))
legend(4, 1, 
       legend=c("2w","8w","1yr"), 
       col=c("green","red","blue"), 
       pch=20)
ordiellipse(BC.nmds, 
            groups=meta$AgeGroup, 
            display="sites", 
            kind="se", 
            conf=0.99, 
            label=FALSE, 
            col="green", 
            draw="polygon", 
            alpha=200, 
            show.groups = c("2w"), 
            border=FALSE)
ordiellipse(BC.nmds, 
            groups=meta$AgeGroup, 
            display="sites", 
            kind="se", 
            conf=0.99, 
            label=FALSE, 
            col="red", 
            draw="polygon", 
            alpha=200, 
            show.groups = c("8w"), 
            border=FALSE)
ordiellipse(BC.nmds, 
            groups=meta$AgeGroup, 
            display="sites", 
            kind="se", 
            conf=0.99, 
            label=FALSE, 
            col="blue", 
            draw="polygon", 
            alpha=200, 
            show.groups = c("1yr"), 
            border=FALSE)
```
<br>
We can see that the Jaccard index for 2 and 8 weeks is quite similair, and that there's a big difference with the Jaccard index for 1 year. This is all similar to the Bray-Curtis dissimilarity that we saw in the tutorial.